<!--
Bug:

Here is the decoded data from Chrome and Firefox:
584 01010001 01010001
585 01100001 01100001
INEQUAL 586 00000100 00010011
INEQUAL 587 01100100 00100011


B123 decoded: 00000100 01100100
B64 decoded:  00010011 00100011
Is NodeJS encoding the correct data for raw data byte 586?
-->
<!doctype html>

<html lang="en">
<head>
    <meta charset="utf-8">

    <title>Test</title>
    <meta name="description" content="">
    <meta name="author" content="Kevin Albertson">

    <style type="text/css">
    </style>

    <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>

<body>
    <img data-b123="v~Â€ J#(`Â„Â€Â ÂˆÂm@0Â˜ @0Æ†A``@( Æ…!PPq `0Æ…BaPtJÊ†d1`X, 21R*F#ri@Z(	%I#[Â`8Æ„B0P(Ò¨Ê…CÏ P(Æ…A P(Æ…A P(Æ…A P(Æ…A P(Æ…A P(Æ…A P(Æ…GÂˆBÂ„ÂÂƒÃˆ@ÂD@?| Â¶Â€Ã ÂŒÂ€Â€Â€Â€Â€Â€  Â€A`o~Â”Ã€ Â€Â€Â€Â€Â€Â€Â€Â€Â‡4Â†Ã Âˆ Â€ÂS=UoRQÊºMf+B0GJTcP>Q;PyÖ¦MzLGN!j9TVngOCMk:=E>s(+8g| Ã€Â€@ Â€Â€Â€Â€Â€Â Â‚	Î°)(Î™{ Â Â€ Pf9MS<oj6Tofy3U%r+BeS)yg<O>dSD8-Ai9Xn5sZC6L1)kmnXU2JY!H%Ò–[2x!RK0=*~hd}JÃ­+^7HT[)I(m*DsyB<yÓµ0>sË…6 OhlmXaTK,SrÓ^e>Zu.hZ}Ó!^m1r U| Â¨Ã€Â€Â€Â€Â€Â€Â€Â€Â€~hÂˆÃ€`	|qÂ DÂ€Â€Â€Â€Â€Â€Â€Â€Â ?{ Â Ã€'pDÂ‹Â€Ã@@8Â€Â€Â€Â€Â‚ÂÎ¢	DDHÒ£8dÒƒ	ePl?}PÂÃ€Ã£xpwÖ¥cyF}kFo]4I*4]/YÂ“T<RÖQ	c{-Ó¥5VA0W<DÃˆX%)<Ó´C9sÎ¯>)S4>JM1*N6*Æ‚W,BUyP^=ÇBmJE`lU2Y_p(-JBx(J	U%4<_p.'GQY@cU.j`Hnc:kÆ±fA4:Pm@nmH*^Æ”/o_Fs.G*y*M' y+63b_qÂ‚Ã€ÂÃ€ Â€Â€Â€Â€Ã€	EQ0Ö°Ë‡#mÂÂˆÂH>h2n	4qJ{Q@zgf>%@<`.Ò¨7Oj/gz)yRZ+aDVZh)?Î†Æ‚FDWB	?8(G}`9RxBm*hg8O-M?;6pB4<#j5)s0WÖ—*HiN2:`{lRhKiaL?lXVqÂŸv7/m!uj+h4gpML=Ö®g|Ã£EDS	NPh2^+9Bw3V(ko6p+cÖ¥_v^(2IL^AG;K+2uÇ­t5)(Pt2aO0nË•Ï¢lÊº`vsb!~ 0CADn;1ÆG8|E`M~bSsfU'4Â†Ã ÂˆÂƒÂ€ÂÂPqEasK| Â¨Ã€Â€Â€Â€Â€Â€Â€Â€Â€~hÂˆÃ€`	| qÂ DÂ€Â€Â€Â€Â€Â€Â€Â€Â ?{ Â Ã€'qÂŸDÂ‰Î€Â‚Ã€ Â€Â€Â€Â‚ÂˆÒ”Q8d4Îp|?}PÂÃ€Â“xBkY9dp>+AvÎ•SkP^Xa9yi+=F<viÒ‘ÊŸ8f6@*Â•`4?;S?N+.Ö‡Ps×œu%2MogË¸mWq_prÒ·:)@ FX6	]Ö¿EÆ¿+cÆ—1*:SK|3R,/Mo-ÒLlm(H{pzLADfm@	PMÊa<;a-.2zoÃ 2EI?	|3IjE!,eÇ¥uV~geiÒ›naoOxN	(8_'vq8-0-#n^L'ÎsDgtÂ—?`}X:pjolIc8)]o'|,P+7qM%#>P)/c9I0BO#5<_Æ€X#lcJp`Î•Ò¾GuaÖ‡H@UH9xe(vWPqliuGzN!OFÏ€8j}qi/$k8W9~@ECj)ntnv:c8`2$]:kt9×ŒADQX?S<Rg[Â„)^S*5gÆ¸95~Y[ÇÎ¿dË¡4qq}[0}|qÎ¥T?Rg2" />
    <script>
        // This is a copy of the NodeJS version of the decode function adorned functionality for the web.
        // Include this function in HTML pages with base123 encoding.
        let specials = [
            0 // null
            , 10 // newline                
            , 13 // carriage return
            , 34 // double quote
            , 38 // ampersand
            , 92 // backslash
        ]
        , kHeader = 0b00001111 // Enforce odd and greater than 13 to avoid special chars.
        , kShortened = 0b01000000
        ;
        // Bitwise order of operations (according to MDN)
        // ~ << >> >>> & ^ |
        // Subtraction (-) comes before all.
        // Base for web function.
        function decodeString(strData) {
            let decoded = [];
            let curByte = 0;
            let bitOfByte = 0;
            let header = strData.charCodeAt(0);

            function push7(byte) {
                byte <<= 1;
                // Align this byte to offset for current byte.
                curByte = curByte | byte >>> bitOfByte;
                // Explanation:
                bitOfByte += 7;
                if (bitOfByte >= 8) {
                    decoded.push(curByte);
                    bitOfByte -= 8;
                    // Now, take the remainder, left shift by what has been taken.
                    curByte = byte << 7 - bitOfByte & 255;
                }
            }
            
            for (var i = 1; i < strData.length; i++) {
                let c = strData.charCodeAt(i);

                // Check for a leading 1 bit, indicating a two-byte character.
                if (c > 127) {
                    // Note, the charCodeAt will give the codePoint, thus
                    // 0b110xxxxx 0b10yyyyyy will give => xxxxxyyyyyy
                    
                    var specialIndex = c >>> 8 & 7; // 7 = 0b111. Note, >>> precedes &
                    push7(specials[specialIndex]);

                    // Skip the remainder only if this is the last character and the header says so.
                    if (i == strData.length - 1 && (header & kShortened)) continue;
                    push7(c & 0x7F); // Note order of operations.
                } else {
                    // Regular ascii.
                    push7(c);
                }
            }
            return decoded;
        }


        function decode(el) {
            var str = el.dataset.b123;
            var mime = el.dataset.b123m || 'image/png';
            inflated = new Uint8Array(decodeString(str));
            var blob = new Blob([inflated], {type: mime});
            console.log(blob);
            var url = URL.createObjectURL(blob);
            el.src = url;
        }

        document.querySelectorAll('[data-b123]').forEach(el => decode(el));
    </script>
</body>
